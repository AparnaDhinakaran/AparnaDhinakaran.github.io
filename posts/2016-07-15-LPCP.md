---
title: An Introduction to LPCPs and LIPs
author: Pratyush
---
This is a project to help understand a simple Linear PCP construction.

We begin by specifying a simple arithmetic circuit that performs the following
operation:

$$C(a, b, c, d, e, f, g) = a \cdot b + b \cdot c + d\cdot e \cdot f \pmod{29}$$

Say the prover $\mathcal{P}$ claims that for input of $\vec{x} = (a,b,c) = (10,
15, 16)$, there exists an assignment to $\vec{w} = (d,e, f)$ such that the
circuit evaluates to $16 \pmod{29}$. Say this $(d,e,f) = (5,19, 4)$. We can
denote this as an arithmetic circuit. TODO: Insert IMAGE.

Based on this circuit, we can assign a numbering to the wires. Let the value of
the $i^{th}$ wire under an assignment is represented by $z_i$. Then, following
the exposition in Bitansky et al. [BCIOP13], the prover $\mathcal{P}$ encodes
the wire assignment $\vec{z}$ as $\vec{\pi} = (z, z \otimes z)$.

<div class="sage">
  <script type="text/x-sage">
  class Circuit():
    def __init__(self, input_wires, input_values, add_gates, mult_gates, output_wires, output_values, number_of_wires):
        self.input_wires = input_wires
        self.input_values = input_values
        self.add_gates = add_gates
        self.mult_gates = mult_gates
        self.output_wires = output_wires
        self.output_values = output_values
        self.number_of_wires = number_of_wires
  </script>
</div>

To check the correctness of $\pi$, the verifier $\mathcal{V}$ has to check 4 conditions:

*   The assignment is self-consistent, i.e., $\pi$ really is of the form $(z, z \otimes z)$.
*   The input portion of the assignment corresponds to the actual input.
*   The output wire is $16 \pmod{29}$.
*   The gates are computed correctly.



<div class="sage">
  <script type="text/x-sage">
  class LPCP_Prover():
    def __init__(self, circuit, field, wire_assignment):
        self.circuit = circuit
        self.field = field
        self.wire_assignment = wire_assignment
        self.generate_lpcp()


    def generate_lpcp(self):
        z2 = self.wire_assignment.tensor_product(self.wire_assignment)
        z_prod = self.wire_assignment.list()[:]
        for elem in z2[:]:
            z_prod = z_prod + elem.list()
        self.pi = vector(self.field, z_prod)


    def answer_query(self, query):
        return self.pi.dot_product(query)

class LPCP_Verifier():
    def __init__(self, circuit, field):
        self.field = field
        self.circuit = circuit
        self.generate_queries(self.circuit, self.field)


    # q_1 and q_2 check for self-consistency.
    # q_1 is a random subset sum of the wire assignments z, and q_2 is the square of
    def generate_q1_q2(self, c, F):
        q_1 = []
        for i in range(n):
            q_1.append(randint(0,F.order()-1))

        q_1_temp = vector(F, q_1)
        q_2 = q_1_temp.tensor_product(q_1_temp)

        for i in range(proof_length-n):
            q_1.append(0);

        q_2_temp = []

        for i in range(n):
            q_2_temp.append(0)

        for elem in q_2:
            q_2_temp = q_2_temp + elem.list()

        q_1 = vector(F, q_1)
        q_2 = vector(F, q_2_temp)
        return (q_1, q_2)


    def generate_q3(self, c, F):
        # Now we have to check that the gates are consistent.
        iden = matrix.identity(F, proof_length)
        zero = vector(F, proof_length)

        constraints = []
        rhs = []

        # Input constraints:
        for i in range(len(c.input_wires)):
            constraints.append(iden.column(c.input_wires[i]-1))
            rhs.append(iden.column(c.input_wires[i]-1)*c.input_values[i])

        # Output constraints:
        for i in range(len(c.output_wires)):
            constraints.append(iden.column(c.output_wires[i]-1))
            rhs.append(iden.column(c.output_wires[i]-1)*c.output_values[i])

        # Addition gates:
        for gate in c.add_gates:
            i,j,k = gate
            constraints.append(iden.column(i-1) + iden.column(j-1) - iden.column(k-1))
            rhs.append(zero)

        # Multiplication gates:
        for gate in c.mult_gates:
            i,j,k = gate
            constraint = iden.column(i*n + j-1) - iden.column(k-1)
            constraints.append(constraint)
            rhs.append(zero)

        constraint_matrix = matrix(F, constraints)

        # Subset sum of constraints:
        r = []
        for i in range(len(constraints)):
            r.append(randint(0,F.order()-1))

        r = vector(F, r)

        q_3 = r*constraint_matrix

        rhs_matrix = matrix(F, rhs)
        correct_a_3 = sum(r*rhs_matrix)
        return q_3, correct_a_3


    def generate_queries(self, c, F):
        self.q_1, self.q_2 = self.generate_q1_q2(c, F)
        self.q_3, self.expected_a_3 = self.generate_q3(c, F)


    def verify_answers(self, a_1, a_2, a_3):
        if (a_1**2 == a_2) and (a_3 == self.expected_a_3):
            return True
        return False


    def get_queries(self):
        return (self.q_1, self.q_2, self.q_3)


input_wires = [1,2,3]
input_values = [10, 15, 16]
add_gates = [(1,3,7), (9,10,11)]
mult_gates = [(2,7,9), (4,5,8), (8,6,10)]
output_wires = [11]
output_values = [16]
number_of_wires = 11

c = Circuit(input_wires, input_values, add_gates, mult_gates,
            output_wires, output_values, number_of_wires)
F = GF(29)

n = c.number_of_wires
proof_length = n**2 + n

z = vector(F, [10, 15, 16, 5, 19, 4, 26, 95, 26*15, 380, 26*15 + 380])

P = LPCP_Prover(c, F, z)
V = LPCP_Verifier(c, F)
queries = V.get_queries()
prover_answers = map(P.answer_query, queries)

# Now the verifier checks that proof is correct:
if (V.verify_answers(*tuple(prover_answers))):
    print("LPCP verifier accepts.")
else:
    print("LPCP verifier rejects.")
  </script>
</div>

Bitansky et al. [BCIOP13] describe a generic transformation from an LPCP to
a LIP. This is achieved by ensuring that the LIP prover
$\mathcal{P}_{\mathsf{LIP}}$ doesn't use a different linear function to answer
the different queries. To do this the LIP verifier $\mathcal{V}_\mathsf{LIP}$
generates a new query that is a random subset sum of the of the LPCP queries.

<div class="sage">
  <script type="text/x-sage">
  class LIP_Prover():
    def __init__(self, circuit, field, wire_assignment):
        self.circuit = circuit
        self.field = field
        self.wire_assignment = wire_assignment
        self.LPCP_P = LPCP_Prover(circuit, field, wire_assignment)


    def answer_query(self, query):
        return self.LPCP_P.answer_query(query)

class LIP_Verifier():
    def __init__(self, circuit, field):
        self.circuit = circuit
        self.field = field
        self.LPCP_V = LPCP_Verifier(circuit, field)
        self.generate_queries()


    def generate_queries(self):
        self.q_1, self.q_2, self.q_3 = self.LPCP_V.get_queries()
        self.r_1, self.r_2, self.r_3 = randint(0,F.order()-1), randint(0,F.order()-1), randint(0,F.order()-1)
        self.q_4 = self.r_1*self.q_1 + self.r_2*self.q_2 + self.r_3*self.q_3


    def get_queries(self):
        return self.q_1, self.q_2, self.q_3, self.q_4


    def verify_answers(self, a_1, a_2, a_3, a_4):
        if (a_4 != (self.r_1*a_1 + self.r_2*a_2 + self.r_3*a_3)):
            return False
        elif (not self.LPCP_V.verify_answers(a_1, a_2, a_3)):
            return False
        return True


P = LIP_Prover(c, F, z)
V = LIP_Verifier(c, F)
queries = V.get_queries()
prover_answers = map(P.answer_query, queries)

# Now the verifier checks that proof is correct:
if (V.verify_answers(*tuple(prover_answers))):
    print("LIP verifier accepts.")
else:
    print("LIP verifier rejects.")
  </script>
</div>
